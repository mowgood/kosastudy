## [day54] 2023.05.30 화 학습 내용 정리
1. Spring Security
2. JWT (JSON Web Token)  
---
## 1. Spring Security
### Token 인증  
- 토큰 기반 인증 시스템은 클라이언트가 서버에 접속하면 해당 **클라이언트**에게 인증되었다는 의미로 **토큰**을 부여한다. 
- 이 토큰은 유일하며 토큰을 발급받은 클라이언트는 또 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다.
- 그러면 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리하게 된다.

### Token의 장점 및 사용 (기존 세션기반 방식과 비교)
- 기존 서버(세션)기반 인증
    - 서버가 파일이나 데이터베이스에 세션정보를 가지고 있어야 하고 이를 조회하는 과정 필요 -> **많은 오버헤드가 발생**
    - 클라이언트로부터 요청을 받으면 클라이언트의 상태를 계속해서 유지해놓고 사용(Stateful)
        - 이는 사용자 증가에 따라 성능 문제를 일으킬 수 있고 확장성이 어렵다.
- 토큰 방식
    - 서버가 아닌 **클라이언트에 저장**되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.
        - 토큰 자체에 데이터가 들어있기 때문에 클라이언트에서 받아 위조되었는지 판별만 하면 되기 때문이다.
    - 토큰은 앱과 서버가 통신 및 인증할 때 가장 많이 사용된다.
        - 왜냐하면 웹에는 쿠키와 세션이 있지만 앱에서는 없기 때문이다.
    - 서버 기반 인증 시스템과 달리 상태를 유지하지 않으므로 Stateless한 특징을 가지고 있다.

### Token 방식의 단점
- 쿠키/세션과 달리 토큰 자체의 데이터 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질 수 있다.
- Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.
- 토큰을 탈취당하면 대처하기 어렵다.
    - **사용 시간 제한을 설정**하여 극복한다.

### Token 방식 인증 과정
1. 사용자가 아이디와 비밀번호로 로그인을 한다.
2. 서버 측에서 사용자(클라이언트)에게 유일한 토큰을 발급한다.
3. 클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장해 두고, 서버에 요청을 할 때마다 해당 토큰을 HTTP 요청 헤더에 포함시켜 전달한다.
4. 서버는 전달받은 토큰을 검증하고 요청에 응답한다.
5. 토큰에는 요청한 사람의 정보가 담겨있으므로 서버는 DB를 조회하지 않고 누가 요청하는지 알 수 이다.

## 2. JWT (JSON Web Token)  
    - 인증에 필요한 정보들을 암호화시킨 JSON 토큰.  
    - JWT 기반 인증은 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식이다.  

### JWT 구조   
- JSON 데잍터를 Base64 URL-safe Encode를 통해 인코딩하여 직렬화한 것.  
- Header
    - JWT에서 사용할 타입과 해시 알고리즘의 종류가 담겨 있다.
- Payload
    - 서버에서 첨부한 사용자 권한 정보와 데이터가 담겨 있다.
- Signature
    - Header, Payload를 Base64 URL-safe Encode를 한 이후 Header에 명시된 해시함수를 적용하고, 개인키로 서명한 전자서명이 담겨있다.

### JWT를 이용한 인증 과정  
1. 사용자가 IP, PW를 입력하여 서버에 로그인 인증을 요청한다.
2. 서버에서 클라이언트로부터 인증 요청을 받으면, Header, PayLoad, Signature를 정의한다. Header, PayLoad, Signature를 각각 Base64로 한 번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아(응답 헤더) 클라이언트에게 발급한다. 클라이언트는 서버로부터 받은 JWT를 로컬 스토리지에 저장한다. (쿠키나 다른 곳에 저장도 가능)
3. API를 서버에 요청할 때 Authorization header에 Access Token을 담아서 보낸다. 서버가 할 일은 클라이언트가 Header에 담아서 보낸 JWT가 내 서버에서 발행한 토큰인지 일치 여부를 확인하여 일치한다면 인증을 통과시켜주고 아니라면 통과시키지 않으면 된다.
4. 인증이 통과되었으므로 페이로드에 들어있는 유저의 정보들을 select하여 클라이언트에 응답한다.   
5. 클라이언트가 서버에 요청을 했는데, 만일 액세스 토큰의 시간이 만료되면 클라이언트는 리프래시 토큰을 이용해서 서버로부터 새로운 엑세스 토큰을 발급 받는다.  

### JWT 장점  
- Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.
- 인증 정보에 대한 별도의 저장소가 필요없다.
- JWT는 토큰에 대한 기본 정보와 전달한 정보 및 토큰이 검증되었음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있다.
- 클라이언트 인증 정보를 저장하는 세션과 다르게, 서버는 무상태(Stateless)가 되어 서버 확장성이 우수해질 수 있다.
- 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다.
- OAuth(Open Authorization)의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹서비스에서도 로그인 할 수 있다. 모바일 어플리케이션 환경에서도 잘 동작한다. (모바일은 세션 사용 불가능)  

> 서버에서 가장 피해야 할 것은 데이터베이스 조회이다.  
> 서버 자체가 죽는 경우도 있지만, 대부분 DB가 터져서 서버도 같이 죽는 경우가 허다하다.  
> 여기서, JWT 토큰은 DB조회를 안해도 되는 장점을 가지고 있다.  
> 만일 payload에 유저이름과 유저등급을 같이 두고 보내면, 서버에서는 유저이름을 가지고 DB를 조회해서 유저 등급을 얻지 않아도 바로 원하는 정보를 얻을 수 있다. 

### JWT 단점  
- Self-contained  
토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다.
- 토큰 길이  
토큰의 Payload에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다.
- Payload 인코딩  
payload 자체는 암호화된 것이 아니라 BASE64로 인코딩된 것이기 때문에, 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, payload에 중요 데이터를 넣지 않아야 한다.
- Store Token  
stateless 특징을 가지기 때문에, 토큰은 클라이언트 측에서 관리하고 저장한다. 때문에 토큰 자체를 탈취당하면 대처하기가 어렵게 된다. 

### Access Token 과 Refresh Token  
JWT도 제 3자에게 토큰 탈취의 위험성이 있기 때문에, 그대로 사용하는 것이 아닌 Access Token, Refresh Token으로 이중으로 나누어 인증하는 방식을 사용한다.
이는 둘 다 똑같은 JWT이다. 다만 토큰이 어디에 저장되고 관리되느냐에 따른 사용 차이가 있다.  
- Access Token  
클라이언트가 갖고 있는 실제로 유저의 정보가 담긴 토큰으로, 클라이언트에서 요청이 오면 서버에서 해당 토큰에 있는 정보를 활용하여 사용자 정보에 맞게 응답을 진행
- Refresh Token  
새로운 Access Token을 발급해주기 위해 사용하는 토큰으로 짧은 수명을 가지는 Access Token에게 새로운 토큰을 발급해주기 위해 사용. 해당 토큰은 보통 데이터베이스에 유저 정보와 같이 기록한다.  
`Access Token은 접근에 관여하는 토큰, Refresh Token은 재발급에 관여하는 토큰의 역할로 사용되는 JWT라고 말할 수 있다.`  

### JWT를 통한 인증 절차
1. 사용자가 로그인을 한다.
2. 서버에서는 계정 정보를 읽어 사용자를 확인 후, 사용자의 고유 ID 값을 부여한 후 기타 정보와 함께 Payload에 집어넣는다.
3. JWT 토큰의 유효기간을 설정한다.
    - 암호화할 Secret Key를 이용해 Access Token을 발급한다. 클라이언트는 Access Token을 받아 저장 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다.
    - 서버에서는 해당 토큰의 Verify Signature를 Secret Key로 복호화한 후, 조작 여부, 유효 기간을 확인한다.
    - 검증이 완료되었을 경우, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.
> 보안 문제 때문에 보통 Access Token의 유효 기간은 매우 짧다. 그래서 Refresh Token을 따로 발급해주는데, Access Token이 만료되면 새로운 JWT를 발급할 수 있는 토큰이다. 

### Refresh Token 절차  
`Access Token을 재발급 하기위한 Token`  
1. 클라이언트에서 로그인한다.
2. 서버는 클라이언트에게 Access Token과 Refresh Token을 발급한다. 동시에 Refresh Token은 서버에 저장된다. 클라이언트는 local 저장소에 두 Token을 저장한다. 
3. 매 요청마다 Access Token을 헤더에 담아서 요청한다.
4. 이 때, Access Token이 만료가 되면 서버는 만료되었다는 Response를 하게 된다.
5. 클라이언트는 해당 Response를 받으면 Refresh Token을 보낸다.
6. 서버는 Refresh Token 유효성 체크를 하게 되고, 새로운 Access Token을 발급한다.
7. 클라이언트는 새롭게 받은 Access Token을 기존의 Access Token에 덮어쓰게 된다.

> EX  
> Access Token 만료 기간 : 30분 ~ 1시간  
> Refresh Token 만료 기간 : 3일 ~ 1달